#!/usr/bin/env python3
"""
Visualizer for Any6D folder results generated by folder_demo.py.
Loads meshes, poses, and point clouds for multiple frames and allows navigation with N/B keys.
Usage: python visualize_folder_results.py ./results_folder/bottle [--mesh path/to/mesh.obj]
"""

import argparse
import os
import glob
import numpy as np
import trimesh
import cv2
import vispy.scene
from vispy.scene import visuals

try:
    import open3d as o3d
    HAS_O3D = True
except ImportError:
    HAS_O3D = False


def find_frame_ids(poses_dir):
    """Find all frame IDs from pose files."""
    pattern = os.path.join(poses_dir, "*.txt")
    pose_files = glob.glob(pattern)
    frame_ids = [os.path.splitext(os.path.basename(f))[0] for f in pose_files]
    frame_ids.sort()
    return frame_ids


# def load_frame_data(result_dir, frame_id, mesh_path=None):
#     """Load mesh, pose matrix, and point cloud for a specific frame."""
#     result_dir = os.path.abspath(result_dir)
    
#     # Determine mesh path
#     if mesh_path is not None:
#         # Use provided mesh file
#         mesh_file = mesh_path
#     else:
#         # Use frame-specific mesh
#         mesh_file = os.path.join(result_dir, "meshes", f"final_mesh_{frame_id}.obj")
    
#     pose_file = os.path.join(result_dir, "poses", f"{frame_id}.txt")
#     points_file = os.path.join(result_dir, "points", f"{frame_id}.npy")
    
#     if not os.path.isfile(mesh_file):
#         raise FileNotFoundError(f"Mesh not found: {mesh_file}")
#     if not os.path.isfile(pose_file):
#         raise FileNotFoundError(f"Pose not found: {pose_file}")
#     if not os.path.isfile(points_file):
#         raise FileNotFoundError(f"Point cloud not found: {points_file}")
    
#     # Load mesh (can be a Scene with multiple geometries)
#     mesh_obj = trimesh.load(mesh_file, force="mesh")
#     if isinstance(mesh_obj, trimesh.Scene):
#         geoms = list(mesh_obj.geometry.values())
#         if not geoms:
#             raise ValueError(f"No geometry in {mesh_file}")
#         mesh_obj = geoms[0]
#     vertices = np.asarray(mesh_obj.vertices, dtype=np.float32)
#     faces = np.asarray(mesh_obj.faces, dtype=np.uint32)
    
#     # 4x4 pose (object -> camera/world); apply to mesh vertices
#     pose = np.loadtxt(pose_file, dtype=np.float64)
#     assert pose.shape == (4, 4), f"Expected 4x4 pose, got {pose.shape}"
#     ones = np.ones((len(vertices), 1), dtype=np.float64)
#     vertices_h = np.hstack([vertices, ones])
#     vertices_t = (pose @ vertices_h.T).T[:, :3].astype(np.float32)
    
#     # Point cloud from numpy file
#     points = np.load(points_file).astype(np.float32)
#     # Handle different point cloud formats
#     if points.ndim == 3:
#         # (H, W, 3) format - flatten to (N, 3)
#         points = points.reshape(-1, 3)
#     elif points.ndim == 2 and points.shape[1] == 3:
#         # Already (N, 3) format
#         pass
#     else:
#         raise ValueError(f"Unexpected point cloud shape: {points.shape}")
    
#     # Invert y and z axes (matching visualize_result.py)
#     # points[:, 2] = -points[:, 2]
#     # points[:, 1] = -points[:, 1]
    
#     # No colors for now (can be extended if needed)
#     colors = None
    
#     return {
#         "vertices": vertices_t,
#         "faces": faces,
#         "points": points,
#         "point_colors": colors,
#         "pose": pose,
#     }


class FolderVisualizer:
    def __init__(self, result_dir, mesh_path=None):
        self.result_dir = os.path.abspath(result_dir)
        self.mesh_path = mesh_path
        self.poses_dir = os.path.join(self.result_dir, "poses")
        
        if not os.path.isdir(self.poses_dir):
            raise FileNotFoundError(f"Poses directory not found: {self.poses_dir}")
        
        # Find all frame IDs
        self.frame_ids = find_frame_ids(self.poses_dir)
        if len(self.frame_ids) == 0:
            raise ValueError(f"No frames found in {self.poses_dir}")
        
        self.current_frame_idx = 0
        self.current_data = None
        
        # Cache base mesh if using a single mesh file
        self.base_mesh_vertices = None
        self.base_mesh_faces = None
        if self.mesh_path is not None:
            mesh_obj = trimesh.load(self.mesh_path, force="mesh")
            if isinstance(mesh_obj, trimesh.Scene):
                geoms = list(mesh_obj.geometry.values())
                if not geoms:
                    raise ValueError(f"No geometry in {self.mesh_path}")
                mesh_obj = geoms[0]
            self.base_mesh_vertices = np.asarray(mesh_obj.vertices, dtype=np.float32)
            self.base_mesh_faces = np.asarray(mesh_obj.faces, dtype=np.uint32)
        
        # Setup vispy canvas
        self.canvas = vispy.scene.SceneCanvas(keys="interactive", show=True, title="Any6D Folder Results")
        self.view = self.canvas.central_widget.add_view()
        self.view.bgcolor = "gray"
        grid = visuals.GridLines(color=(0.5, 0.5, 0.5, 0.5), parent=self.view.scene)

        # Create visuals (will be updated)
        self.mesh_visual = visuals.Mesh(
            vertices=np.array([[0, 0, 0]], dtype=np.float32),
            faces=np.array([], dtype=np.uint32),
            color=(0.45, 0.55, 0.85, 0.9),
            shading="smooth",
        )
        self.view.add(self.mesh_visual)
        
        self.scatter = visuals.Markers()
        self.scatter.set_data(
            np.array([[0, 0, 0]], dtype=np.float32),
            face_color=(1.0, 0.85, 0.4, 0.6),
            edge_width=0,
            size=2.0,
        )
        self.view.add(self.scatter)
        
        # Coordinate axes
        self.axis = visuals.XYZAxis(parent=self.view.scene)
        
        self.view.camera = "turntable"
        # self.view.camera.depth_value = 1e4
        
        # Setup keyboard callbacks
        self.canvas.events.key_press.connect(self.on_key_press)
        
        # Load initial frame
        self.load_frame(self.current_frame_idx)
        
        print(f"Loaded {len(self.frame_ids)} frames")
        print("Controls:")
        print("  N = Next frame")
        print("  B = Previous frame")
        print("  Rotate = drag, zoom = scroll, pan = right-drag")
    
    def load_frame(self, frame_idx):
        """Load and display a specific frame."""
        if frame_idx < 0 or frame_idx >= len(self.frame_ids):
            return
        
        self.current_frame_idx = frame_idx
        frame_id = self.frame_ids[frame_idx]
        
        print(f"Loading frame {frame_idx + 1}/{len(self.frame_ids)}: {frame_id}")
        
        try:
            # Load pose and point cloud
            pose_file = os.path.join(self.result_dir, "poses", f"{frame_id}.txt")
            points_file = os.path.join(self.result_dir, "points", f"{frame_id}.npy")
            
            if not os.path.isfile(pose_file):
                raise FileNotFoundError(f"Pose not found: {pose_file}")
            if not os.path.isfile(points_file):
                raise FileNotFoundError(f"Point cloud not found: {points_file}")
            
            # Load pose
            pose = np.loadtxt(pose_file, dtype=np.float64)
            assert pose.shape == (4, 4), f"Expected 4x4 pose, got {pose.shape}"
            
            # Load or use cached mesh vertices
            if self.base_mesh_vertices is not None:
                # Use cached base mesh and apply pose
                vertices = self.base_mesh_vertices
                faces = self.base_mesh_faces
            else:
                # Load frame-specific mesh
                mesh_file = os.path.join(self.result_dir, "meshes", f"final_mesh_{frame_id}.obj")
                if not os.path.isfile(mesh_file):
                    raise FileNotFoundError(f"Mesh not found: {mesh_file}")
                mesh_obj = trimesh.load(mesh_file, force="mesh")
                if isinstance(mesh_obj, trimesh.Scene):
                    geoms = list(mesh_obj.geometry.values())
                    if not geoms:
                        raise ValueError(f"No geometry in {mesh_file}")
                    mesh_obj = geoms[0]
                vertices = np.asarray(mesh_obj.vertices, dtype=np.float32)
                faces = np.asarray(mesh_obj.faces, dtype=np.uint32)
            
            # Apply pose to mesh vertices
            ones = np.ones((len(vertices), 1), dtype=np.float64)
            vertices_h = np.hstack([vertices, ones])
            vertices_t = (pose @ vertices_h.T).T[:, :3].astype(np.float32)
            
            # Load point cloud
            points = np.load(points_file).astype(np.float32)
            original_shape = points.shape
            points_was_3d = points.ndim == 3
            
            # Handle different point cloud formats
            if points.ndim == 3:
                # (H, W, 3) format - flatten to (N, 3)
                H, W, _ = points.shape
                points = points.reshape(-1, 3)
            elif points.ndim == 2 and points.shape[1] == 3:
                # Already (N, 3) format
                H, W = None, None
                pass
            else:
                raise ValueError(f"Unexpected point cloud shape: {points.shape}")
            
            # Load image colors
            image_file = os.path.join(self.result_dir, "images", f"{frame_id}.jpg")
            colors = None
            if os.path.isfile(image_file):
                image = cv2.imread(image_file)
                if image is not None:
                    # Convert BGR to RGB
                    image_rgb = image #cv2.cvtColor(image, cv2.COLOR_RGB2RGB)
                    # Normalize to [0, 1]
                    colors = image_rgb.astype(np.float32) / 255.0
                    
                    # Flatten colors to match point cloud
                    if points_was_3d:
                        # Points were (H, W, 3), so colors should match
                        # Verify dimensions match
                        if colors.shape[:2] == original_shape[:2]:
                            colors = colors.reshape(-1, 3)
                        else:
                            # Resize image to match point cloud dimensions
                            colors = cv2.resize(colors, (original_shape[1], original_shape[0]))
                            colors = colors.reshape(-1, 3)
                    else:
                        # If points are already flattened, we need to match the shape
                        # This shouldn't happen if points are from MoGe, but handle it
                        if colors.shape[0] * colors.shape[1] == points.shape[0]:
                            colors = colors.reshape(-1, 3)
                        else:
                            colors = None
            
            # swap y and z axes
            points[:, [1, 2]] = points[:, [2, 1]]
            vertices_t[:, [1, 2]] = vertices_t[:, [2, 1]]
            # invert z axis
            points[:, 2] = -points[:, 2]
            vertices_t[:, 2] = -vertices_t[:, 2]
            
            
            self.current_data = {
                "vertices": vertices_t,
                "faces": faces,
                "points": points,
                "point_colors": colors,
                "pose": pose,
            }
            
            # Update mesh visual
            self.mesh_visual.set_data(
                vertices=self.current_data["vertices"],
                faces=self.current_data["faces"],
            )
            
            # Update point cloud with colors
            if self.current_data["point_colors"] is not None:
                # Use per-point colors
                self.scatter.set_data(
                    self.current_data["points"],
                    face_color=self.current_data["point_colors"],
                    edge_width=0,
                    size=2.0,
                )
            else:
                # Use default color
                self.scatter.set_data(
                    self.current_data["points"],
                    face_color=(1.0, 0.85, 0.4, 0.6),
                    edge_width=0,
                    size=2.0,
                )
            
            # Update camera to center on data
            all_pts = np.vstack([self.current_data["vertices"], self.current_data["points"]])
            center = all_pts.mean(axis=0)
            radius = float(np.linalg.norm(all_pts - center, axis=1).max()) * 1.2
            # self.view.camera.center = center
            # self.view.camera.scale_factor = radius
            
            self.canvas.update()
            
        except Exception as e:
            print(f"Error loading frame {frame_id}: {e}")
    
    def on_key_press(self, event):
        """Handle keyboard input."""
        if event.key == 'N':
            # Next frame
            self.load_frame(self.current_frame_idx + 1)
        elif event.key == 'B':
            # Previous frame
            self.load_frame(self.current_frame_idx - 1)
    
    def run(self):
        """Start the visualization."""
        vispy.app.run()


def main():
    parser = argparse.ArgumentParser(
        description="Visualize Any6D folder results (mesh + pose + point cloud) with frame navigation"
    )
    parser.add_argument(
        "result_dir",
        type=str,
        help="Result directory (e.g. ./results_folder/bottle)"
    )
    parser.add_argument(
        "--mesh",
        type=str,
        default=None,
        help="Optional: Use a single mesh file for all frames (updates only pose)"
    )
    args = parser.parse_args()
    
    if args.mesh and not os.path.isfile(args.mesh):
        raise FileNotFoundError(f"Mesh file not found: {args.mesh}")
    
    visualizer = FolderVisualizer(args.result_dir, args.mesh)
    visualizer.run()


if __name__ == "__main__":
    main()
